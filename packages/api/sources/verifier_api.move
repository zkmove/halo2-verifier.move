module verifier_api::verifier_api {
    use std::error;
    use aptos_std::bn254_algebra::Fr;

    use verifier_api::param_store::get_params;

    use halo2_verifier::halo2_verifier::{verify_single, verify_single_vm};
    use halo2_verifier::protocol::{Self, Protocol};
    use halo2_verifier::public_inputs::PublicInputs;

    const VERIFY_PROOF_FAILURE: u64 = 1;

    /// wrapper on protocol
    struct Circuit has key {
        protocol: Protocol,
    }

    /// Publish the circuit under sender account
    public entry fun publish_circuit(
        sender: &signer,
        general_info: vector<vector<u8>>,
        advice_queries: vector<vector<u8>>,
        instance_queries: vector<vector<u8>>,
        fixed_queries: vector<vector<u8>>,
        permutation_columns: vector<vector<u8>>,
        fields_pool: vector<vector<u8>>,
        gates: vector<vector<u8>>,
        lookups_input_exprs: vector<vector<u8>>,
        lookups_table_exprs: vector<vector<u8>>,
        shuffle_input_exprs: vector<vector<u8>>,
        shuffle_exprs: vector<vector<u8>>,
    ) {
        let proto = protocol::from_bytes(
            general_info, advice_queries, instance_queries, fixed_queries, permutation_columns,
            fields_pool, gates, lookups_input_exprs, lookups_table_exprs, shuffle_input_exprs,
            shuffle_exprs
        );
        move_to(sender, Circuit { protocol: proto });
    }

    public entry fun verify_proof_gwc(param_address: address,
                                  circuit_address: address,
                                  instances: vector<vector<vector<u8>>>,
                                  proof: vector<u8>) acquires Circuit {
        verify_proof(param_address,circuit_address,instances,proof, 0);
    }
    public entry fun verify_proof_shplonk(param_address: address,
                                      circuit_address: address,
                                      instances: vector<vector<vector<u8>>>,
                                      proof: vector<u8>) acquires Circuit {
        verify_proof(param_address,circuit_address,instances,proof, 1);
    }

    /// verify proof with given kzg variant, 0: gwc, 1: shplonk
    public entry fun verify_proof(
        param_address: address,
        circuit_address: address,
        instances: vector<vector<vector<u8>>>,
        proof: vector<u8>,
        kzg_variant: u8,
    ) acquires Circuit {
        let params = get_params(param_address);
        let circuit = borrow_global<Circuit>(circuit_address);
        let protocol = &circuit.protocol;
        assert!(verify_single(&params, protocol, instances, proof, kzg_variant), error::aborted(VERIFY_PROOF_FAILURE));
    }

    /// mock verify proof, do nothing
    public entry fun mock_verify_proof(
        _param_address: address,
        _circuit_address: address,
        _instances: vector<vector<vector<u8>>>,
        _proof: vector<u8>,
        _kzg_variant: u8,
    ) {
        // do nothing
    }

    /// verify proof with given kzg variant, 0: gwc, 1: shplonk
    /// different from verify_proof, this function takes PublicInputs struct as input
    /// and the proof must be generated by zkmove vm
    public fun verify(
        param_address: address,
        circuit_address: address,
        public_inputs: PublicInputs<Fr>,
        proof: vector<u8>,
        kzg_variant: u8,
    ): bool acquires Circuit {
        let params = get_params(param_address);
        let circuit = borrow_global<Circuit>(circuit_address);
        let protocol = &circuit.protocol;
        verify_single_vm(&params, protocol, public_inputs, proof, kzg_variant)
    }

    /// mock verify always returns true
    public fun mock_verify(
        _param_address: address,
        _circuit_address: address,
        _public_inputs: PublicInputs<Fr>,
        _proof: vector<u8>,
        _kzg_variant: u8,
    ): bool {
        true
    }

    /// destory a circuit
    public fun destroy(circuit: Circuit) {
        let Circuit { protocol: _ } = circuit;
    }
}
